@@arr_mod

import libc { malloc, realloc, free }
import drop::Drop

# trait Index[type Key, type El]
#     fn index(self: *Self, i: Key) -> El

pub struct arr[type El, usize Len]
    pub count: usize
    # data: &(El * Len)
    data: &[El * Len]

# impl arr: Index[Len, El]
#     fn index(self: *arr, i: usize) -> El
#         unsafe (borrow self.data)^[i]

# struct slice[type El]
#     pub count: usize
#     data: &(El * Len)

# impl arr: Index[usize..usize, slice[El]]
#     @borrows_out(return -> self.data)
#     fn index(self: *arr, i: usize..usize) -> slice[El]
#         unsafe slice { count: i.end - i.start, data: (borrow self.data as &El) + i.start }

pub struct vec[type El]
    pub count: usize
    cap: usize
    # data: owned(malloc, free) &(El * ?)
    data: owned(malloc, free) &El

impl vec: Drop
    fn drop(self: &mut vec)
        unsafe free(self^.data)

# impl vec: Index[usize, El]
#     fn index(self: *arr, i: usize)
#         unsafe (borrow self.data)^[i]

impl vec
    pub fn new() -> vec
        let cap = 16usz
        let data = unsafe malloc(cap * sizeof El) as owned(malloc, free) &El
        vec { count: 0, cap: cap, data: data }
    
    pub fn push(self: &mut vec, item: El)
        if self^.count == self^.cap
            self^->grow()
        (borrow self^.data as &[El * 0])^[self^.count] = item
        self^.count += 1
    
    fn grow(self: &mut vec)
        self^.cap *= 2
        self^.data = unsafe realloc(
            self^.data as owned(malloc, free) &El
            self^.cap * sizeof El) as owned(malloc, free) &El

import libc::printf

fn main()
    let array: arr[int, 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let d = array[4]

    let mut vector = vec[float]::new()
    # let mut vector: vec[float] = vec::new()
    let mut n = 1.3
    while n as int < 20
        vector->push(n)
        n += 0.7
    
    let mut i = 0usz
    while i < vector.count
        unsafe printf("%g\n", vector[i])
        i += 1
    
    unsafe free(vector.data)
    