# trait Index[type Key, type El]
#     fn index(self: *Self, i: Key) -> El

struct arr[type El, usize Len]
    pub count: usize
    # data: &(El * Len)
    data: &[El * Len]

# impl arr: Index[usize, El]
#     fn index(self: *arr, i: usize) -> El
#         unsafe (borrow self.data)^[i]

# struct slice[type El]
#     pub count: usize
#     data: &(El * Len)

# impl arr: Index[usize..usize, slice[El]]
#     @borrows_out(return -> self.data)
#     fn index(self: *arr, i: usize..usize) -> slice[El]
#         unsafe slice { count: i.end - i.start, data: (borrow self.data as &El) + i.start }

# struct vec[type El]
#     pub count: usize
#     cap: usize
#     data: owned(malloc, free) &(El * ?)

# impl vec: Index[usize, El]
#     fn index(self: *arr, i: usize)
#         unsafe (borrow self.data)^[i]

# impl vec
#     pub fn new()
#         let cap = 16
#         let data = malloc(cap * sizeof(El)) as owned(malloc, free) &(El * ?)
#         vec { count: 0, cap: cap, data: data }
    
#     pub fn push(self: *mut vec, item: El)
#         if self.count == self.cap
#             self->grow()
#         self.data^[self.count] = item
#         self.count += 1
    
#     fn grow(self: *mut vec)
#         self.cap *= 2
#         self.data = realloc(
#             self.data as owned(malloc, free) &(El * ?)
#             self.cap * sizeof(El)) as owned(malloc, free) &(El * ?)

import libc::printf

fn main()
    let array: arr[int, 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    # let vector: vec[int] = [1, 2, 3, 4, 5]
    unsafe printf("%d\n", array[11])
    