@@arr_mod

import libc { malloc, realloc, free }

# trait Index[type Key, type El]
#     fn index(self: *Self, i: Key) -> El

struct arr[type El, usize Len]
    pub count: usize
    # data: &(El * Len)
    data: &[El * Len]

# impl arr: Index[usize, El]
#     fn index(self: *arr, i: usize) -> El
#         unsafe (borrow self.data)^[i]

# struct slice[type El]
#     pub count: usize
#     data: &(El * Len)

# impl arr: Index[usize..usize, slice[El]]
#     @borrows_out(return -> self.data)
#     fn index(self: *arr, i: usize..usize) -> slice[El]
#         unsafe slice { count: i.end - i.start, data: (borrow self.data as &El) + i.start }

struct vec[type El]
    pub count: usize
    cap: usize
    # data: owned(malloc, free) &(El * ?)
    data: owned(malloc, free) &El

# impl vec: Index[usize, El]
#     fn index(self: *arr, i: usize)
#         unsafe (borrow self.data)^[i]

impl vec
    pub fn new() -> vec
        let cap = 16usz
        let data = unsafe malloc(cap * sizeof(El)) as owned(malloc, free) &El
        vec { count: 0, cap: cap, data: data }
    
    pub fn push(self: &mut vec, item: El)
        if self^.count == self^.cap
            self^->grow()
        (borrow self^.data as &[El * 0])^[self^.count] = item
        self^.count += 1
    
    fn grow(self: &mut vec)
        self^.cap *= 2
        self^.data = unsafe realloc(
            self^.data as owned(malloc, free) &El
            self^.cap * sizeof(El)) as owned(malloc, free) &El

import libc::printf

fn main()
    let array: arr[int, 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    # let vector: vec[int] = [1, 2, 3, 4, 5]
    unsafe printf("%d\n", array[7])
    